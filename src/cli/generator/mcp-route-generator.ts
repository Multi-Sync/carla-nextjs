/**
 * MCP Route Generator
 *
 * Generates /api/_mcp/route.ts for Model Context Protocol support
 */

import * as fs from 'fs';
import * as path from 'path';
import { ToolsConfig } from '../../types/index.js';

export interface MCPRouteOptions {
  projectRoot: string;
  toolsConfig: ToolsConfig;
}

export class MCPRouteGenerator {
  private projectRoot: string;
  private toolsConfig: ToolsConfig;

  constructor(options: MCPRouteOptions) {
    this.projectRoot = options.projectRoot;
    this.toolsConfig = options.toolsConfig;
  }

  /**
   * Generate MCP route file
   */
  async generate(): Promise<string> {
    const mcpDir = this.getMCPDirectory();
    const routeFilePath = path.join(mcpDir, 'route.ts');

    // Create directory if it doesn't exist
    if (!fs.existsSync(mcpDir)) {
      fs.mkdirSync(mcpDir, { recursive: true });
    }

    // Generate route content
    const content = this.generateRouteContent();

    // Write file
    fs.writeFileSync(routeFilePath, content, 'utf-8');

    return routeFilePath;
  }

  /**
   * Get MCP directory path
   */
  private getMCPDirectory(): string {
    // Try app router first
    const appApiPath = path.join(this.projectRoot, 'app', 'api', '_mcp');
    if (fs.existsSync(path.join(this.projectRoot, 'app'))) {
      return appApiPath;
    }

    // Try src/app router
    const srcAppApiPath = path.join(this.projectRoot, 'src', 'app', 'api', '_mcp');
    if (fs.existsSync(path.join(this.projectRoot, 'src', 'app'))) {
      return srcAppApiPath;
    }

    // Default to app router
    return appApiPath;
  }

  /**
   * Generate route.ts content
   */
  private generateRouteContent(): string {
    // Only include enabled tools
    const enabledTools = this.toolsConfig.tools.filter(t => t.enabled);

    const toolsJson = JSON.stringify(enabledTools, null, 2)
      .split('\n')
      .map(line => '  ' + line)
      .join('\n');

    return `/**
 * MCP (Model Context Protocol) Endpoint
 *
 * This endpoint allows AI agents (Cursor, Claude Desktop, etc.) to interact
 * with your Next.js API routes through the Model Context Protocol.
 *
 * Generated by carla-nextjs
 * @see https://github.com/Multi-Sync/carla-nextjs
 */

import { NextRequest, NextResponse } from 'next/server';

// Tools configuration (only enabled tools)
// Generated from: carla-tools.json
const TOOLS = ${toolsJson.trim()};

/**
 * MCP Protocol Handler
 *
 * Handles MCP protocol messages from AI agents
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { method, params } = body;

    // Handle different MCP methods
    switch (method) {
      case 'tools/list':
        return handleToolsList();

      case 'tools/call':
        return handleToolCall(params);

      default:
        return NextResponse.json(
          { error: \`Unknown method: \${method}\` },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('[MCP] Error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * Handle tools/list request
 * Returns list of available tools
 */
function handleToolsList() {
  const tools = TOOLS.map(tool => ({
    name: tool.name,
    description: tool.description,
    inputSchema: tool.parameters,
  }));

  return NextResponse.json({ tools });
}

/**
 * Handle tools/call request
 * Executes a tool and returns the result
 */
async function handleToolCall(params: any) {
  const { name, arguments: args } = params;

  // Find the tool
  const tool = TOOLS.find(t => t.name === name);
  if (!tool) {
    return NextResponse.json(
      { error: \`Tool not found: \${name}\` },
      { status: 404 }
    );
  }

  try {
    // Build the URL
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    let url = \`\${baseUrl}\${tool.endpoint}\`;

    // For GET requests, add query parameters
    if (tool.method === 'GET' && args) {
      // Replace path parameters (e.g., /users/:id -> /users/123)
      Object.entries(args).forEach(([key, value]) => {
        url = url.replace(\`:\${key}\`, String(value));
      });
    }

    // Make the request
    const fetchOptions: RequestInit = {
      method: tool.method,
      headers: {
        'Content-Type': 'application/json',
      },
    };

    // Add body for non-GET requests
    if (tool.method !== 'GET' && args) {
      fetchOptions.body = JSON.stringify(args);
    }

    const response = await fetch(url, fetchOptions);
    const result = await response.json();

    return NextResponse.json({
      content: [
        {
          type: 'text',
          text: JSON.stringify(result, null, 2),
        },
      ],
    });
  } catch (error) {
    console.error(\`[MCP] Tool execution failed: \${name}\`, error);
    return NextResponse.json(
      {
        error: \`Tool execution failed: \${error instanceof Error ? error.message : 'Unknown error'}\`
      },
      { status: 500 }
    );
  }
}
`;
  }

  /**
   * Check if MCP route already exists
   */
  routeExists(): boolean {
    const mcpDir = this.getMCPDirectory();
    const routeFilePath = path.join(mcpDir, 'route.ts');
    return fs.existsSync(routeFilePath);
  }

  /**
   * Remove MCP route (for eject command)
   */
  remove(): boolean {
    const mcpDir = this.getMCPDirectory();
    if (fs.existsSync(mcpDir)) {
      fs.rmSync(mcpDir, { recursive: true, force: true });
      return true;
    }
    return false;
  }
}
