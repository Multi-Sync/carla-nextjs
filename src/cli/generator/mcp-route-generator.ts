/**
 * MCP Route Generator
 *
 * Generates /api/mcp routes for Model Context Protocol support
 * Creates two endpoints:
 * - GET /api/mcp/tools - Returns tool catalog
 * - POST /api/mcp/call - Executes tools via proxy
 */

import * as fs from 'fs';
import * as path from 'path';
import { ToolsConfig } from '../../types/index.js';

export interface MCPRouteOptions {
  projectRoot: string;
  toolsConfig: ToolsConfig;
  isTypeScript?: boolean;
}

export class MCPRouteGenerator {
  private projectRoot: string;
  private toolsConfig: ToolsConfig;
  private isTypeScript: boolean;
  private fileExtension: string;

  constructor(options: MCPRouteOptions) {
    this.projectRoot = options.projectRoot;
    this.toolsConfig = options.toolsConfig;
    this.isTypeScript = options.isTypeScript ?? true;
    this.fileExtension = this.isTypeScript ? 'ts' : 'js';
  }

  /**
   * Generate MCP route files
   */
  async generate(): Promise<string[]> {
    const mcpDir = this.getMCPDirectory();

    // Create directories
    const toolsDir = path.join(mcpDir, 'tools');
    const callDir = path.join(mcpDir, 'call');

    if (!fs.existsSync(toolsDir)) {
      fs.mkdirSync(toolsDir, { recursive: true });
    }
    if (!fs.existsSync(callDir)) {
      fs.mkdirSync(callDir, { recursive: true });
    }

    // Generate both route files
    const toolsRoutePath = path.join(toolsDir, `route.${this.fileExtension}`);
    const callRoutePath = path.join(callDir, `route.${this.fileExtension}`);

    fs.writeFileSync(toolsRoutePath, this.generateToolsRouteContent(), 'utf-8');
    fs.writeFileSync(callRoutePath, this.generateCallRouteContent(), 'utf-8');

    return [toolsRoutePath, callRoutePath];
  }

  /**
   * Get MCP directory path
   */
  private getMCPDirectory(): string {
    // Try app router first
    const appApiPath = path.join(this.projectRoot, 'app', 'api', '_mcp');
    if (fs.existsSync(path.join(this.projectRoot, 'app'))) {
      return appApiPath;
    }

    // Try src/app router
    const srcAppApiPath = path.join(this.projectRoot, 'src', 'app', 'api', '_mcp');
    if (fs.existsSync(path.join(this.projectRoot, 'src', 'app'))) {
      return srcAppApiPath;
    }

    // Default to app router
    return appApiPath;
  }

  /**
   * Generate GET /api/mcp/tools route
   */
  private generateToolsRouteContent(): string {
    const enabledTools = this.toolsConfig.tools.filter(t => t.enabled);

    const toolsJson = JSON.stringify(enabledTools, null, 2)
      .split('\n')
      .map(line => '  ' + line)
      .join('\n');

    if (this.isTypeScript) {
      return `/**
 * GET /api/mcp/tools
 *
 * Returns catalog of available API tools
 * Generated by carla-nextjs
 */

import { NextResponse } from 'next/server';

// Tools configuration (only enabled tools)
const TOOLS = ${toolsJson.trim()};

export async function GET() {
  try {
    const tools = TOOLS.map(tool => ({
      name: tool.name,
      description: tool.description,
      method: tool.method,
      endpoint: tool.endpoint,
      inputSchema: tool.parameters,
      auth: tool.auth,
    }));

    return NextResponse.json({ tools });
  } catch (error) {
    console.error('[MCP] Error listing tools:', error);
    return NextResponse.json(
      { error: 'Failed to list tools' },
      { status: 500 }
    );
  }
}
`;
    } else {
      // JavaScript version
      return `/**
 * GET /api/mcp/tools
 *
 * Returns catalog of available API tools
 * Generated by carla-nextjs
 */

import { NextResponse } from 'next/server';

// Tools configuration (only enabled tools)
const TOOLS = ${toolsJson.trim()};

export async function GET() {
  try {
    const tools = TOOLS.map(tool => ({
      name: tool.name,
      description: tool.description,
      method: tool.method,
      endpoint: tool.endpoint,
      inputSchema: tool.parameters,
      auth: tool.auth,
    }));

    return NextResponse.json({ tools });
  } catch (error) {
    console.error('[MCP] Error listing tools:', error);
    return NextResponse.json(
      { error: 'Failed to list tools' },
      { status: 500 }
    );
  }
}
`;
    }
  }

  /**
   * Generate POST /api/mcp/call route with proxy logic
   */
  private generateCallRouteContent(): string {
    const enabledTools = this.toolsConfig.tools.filter(t => t.enabled);

    const toolsJson = JSON.stringify(enabledTools, null, 2)
      .split('\n')
      .map(line => '  ' + line)
      .join('\n');

    const importStatement = this.isTypeScript
      ? `import { NextRequest, NextResponse } from 'next/server';`
      : `import { NextResponse } from 'next/server';`;

    const functionSignature = this.isTypeScript
      ? `export async function POST(req: NextRequest) {`
      : `export async function POST(req) {`;

    return `/**
 * POST /api/mcp/call
 *
 * Executes API tools via proxy
 * Request: { tool: "tool_name", args: {...} }
 * Generated by carla-nextjs
 */

${importStatement}

// Tools registry (only enabled tools)
const TOOLS = ${toolsJson.trim()};

${functionSignature}
  try {
    const { tool: toolName, args } = await req.json();

    if (!toolName) {
      return NextResponse.json(
        { error: 'Missing required field: tool' },
        { status: 400 }
      );
    }

    // Find tool in registry
    const tool = TOOLS.find((t) => t.name === toolName);
    if (!tool) {
      return NextResponse.json(
        { error: \`Tool not found: \${toolName}\` },
        { status: 404 }
      );
    }

    // Check auth requirements
    if (tool.auth === 'required') {
      const authHeader = req.headers.get('authorization');
      const hasCookie = req.headers.get('cookie');

      if (!authHeader && !hasCookie) {
        return NextResponse.json(
          { error: 'Authentication required for this tool' },
          { status: 401 }
        );
      }
    }

    // Build endpoint with path parameters
    let endpoint = tool.endpoint;
    const pathParams = new Set<string>();

    if (args) {
      Object.entries(args).forEach(([key, value]) => {
        if (endpoint.includes(\`:\${key}\`)) {
          endpoint = endpoint.replace(\`:\${key}\`, String(value));
          pathParams.add(key);
        }
      });
    }

    // Build target URL
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const host = req.headers.get('host') || 'localhost:3000';
    const baseUrl = \`\${protocol}://\${host}\`;
    const url = \`\${baseUrl}\${endpoint}\`;

    // Prepare fetch options
    const fetchOptions = {
      method: tool.method,
      headers: {
        'Content-Type': 'application/json',
        // Forward authentication
        ...(req.headers.get('authorization') && {
          'Authorization': req.headers.get('authorization')!,
        }),
        ...(req.headers.get('cookie') && {
          'Cookie': req.headers.get('cookie')!,
        }),
        // Forward context headers
        ...(req.headers.get('user-agent') && {
          'User-Agent': req.headers.get('user-agent')!,
        }),
        'X-Forwarded-For': req.headers.get('x-forwarded-for') ||
                           req.headers.get('x-real-ip') ||
                           'mcp-proxy',
      },
    };

    // Add body for non-GET requests (exclude path params)
    if (tool.method !== 'GET' && args) {
      const bodyArgs = { ...args };
      pathParams.forEach(param => delete bodyArgs[param]);

      if (Object.keys(bodyArgs).length > 0) {
        fetchOptions.body = JSON.stringify(bodyArgs);
      }
    }

    // Execute proxied request
    const response = await fetch(url, fetchOptions);

    // Parse response
    const contentType = response.headers.get('content-type');
    let result;

    if (contentType?.includes('application/json')) {
      result = await response.json();
    } else {
      result = {
        status: response.status,
        text: await response.text(),
      };
    }

    // Return normalized response
    return NextResponse.json({
      success: response.ok,
      status: response.status,
      data: result,
    }, { status: response.status });

  } catch (error) {
    console.error('[MCP] Tool execution failed:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
`;
  }

  /**
   * Check if MCP routes already exist
   */
  routeExists(): boolean {
    const mcpDir = this.getMCPDirectory();
    // Check for both .ts and .js extensions
    const toolsRouteTs = path.join(mcpDir, 'tools', 'route.ts');
    const toolsRouteJs = path.join(mcpDir, 'tools', 'route.js');
    const callRouteTs = path.join(mcpDir, 'call', 'route.ts');
    const callRouteJs = path.join(mcpDir, 'call', 'route.js');

    return fs.existsSync(toolsRouteTs) ||
           fs.existsSync(toolsRouteJs) ||
           fs.existsSync(callRouteTs) ||
           fs.existsSync(callRouteJs);
  }

  /**
   * Remove MCP routes (for cleanup)
   */
  remove(): boolean {
    const mcpDir = this.getMCPDirectory();
    if (fs.existsSync(mcpDir)) {
      fs.rmSync(mcpDir, { recursive: true, force: true });
      return true;
    }
    return false;
  }
}
